/**
 * generated by Xtext 2.10.0
 */
package edu.kit.ipd.sdq.kamp.ruledsl.jvmmodel;

import com.google.inject.Inject;
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.BackwardEReference;
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.ForwardEReference;
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.KampRule;
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.Lookup;
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.RuleFile;
import edu.kit.ipd.sdq.kamp.ruledsl.util.EcoreUtil;
import edu.kit.ipd.sdq.kamp.ruledsl.util.KampRuleLanguageEcoreUtil;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * <p>Infers a JVM model from the source model.</p>
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>
 */
@SuppressWarnings("all")
public class KampRuleLanguageJvmModelInferrer extends AbstractModelInferrer {
  /**
   * convenience API to build and initialize JVM types and their members.
   */
  @Inject
  @Extension
  private JvmTypesBuilder _jvmTypesBuilder;
  
  /**
   * associates a variable name with a {@link Lookup}
   */
  private Map<Lookup, String> nameForLookup;
  
  /**
   * The dispatch method {@code infer} is called for each instance of the
   * given element's type that is contained in a resource.
   * 
   * @param element
   *            the model to create one or more
   *            {@link JvmDeclaredType declared
   *            types} from.
   * @param acceptor
   *            each created
   *            {@link JvmDeclaredType type}
   *            without a container should be passed to the acceptor in order
   *            get attached to the current resource. The acceptor's
   *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
   *            accept(..)} method takes the constructed empty type for the
   *            pre-indexing phase. This one is further initialized in the
   *            indexing phase using the lambda you pass as the last argument.
   * @param isPreIndexingPhase
   *            whether the method is called in a pre-indexing phase, i.e.
   *            when the global index is not yet fully updated. You must not
   *            rely on linking using the index if isPreIndexingPhase is
   *            <code>true</code>.
   */
  protected void _infer(final RuleFile element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    final Procedure1<JvmGenericType> _function = (JvmGenericType theClass) -> {
      this.nameForLookup = CollectionLiterals.<Lookup, String>newHashMap();
      EList<JvmMember> _members = theClass.getMembers();
      final Function1<KampRule, JvmOperation> _function_1 = (KampRule rule) -> {
        final Procedure1<JvmOperation> _function_2 = (JvmOperation it) -> {
          EList<JvmFormalParameter> _parameters = it.getParameters();
          JvmFormalParameter _parameter = this._jvmTypesBuilder.toParameter(rule, StringExtensions.toFirstLower(rule.getSource().getMetaclass().getName()), this._typeReferenceBuilder.typeRef(rule.getSource().getMetaclass().getInstanceTypeName()));
          this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, _parameter);
          this.nameForLookup.put(null, "input");
          StringConcatenationClient _client = new StringConcatenationClient() {
            @Override
            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
              JvmTypeReference _typeRef = KampRuleLanguageJvmModelInferrer.this._typeReferenceBuilder.typeRef(Set.class, KampRuleLanguageJvmModelInferrer.this._typeReferenceBuilder.typeRef(Resource.class));
              _builder.append(_typeRef);
              _builder.append(" allResources = ");
              _builder.append(Collections.class);
              _builder.append(".emptySet();");
              _builder.newLineIfNotEmpty();
              _builder.newLine();
              JvmTypeReference _typeRef_1 = KampRuleLanguageJvmModelInferrer.this._typeReferenceBuilder.typeRef(Stream.class, KampRuleLanguageJvmModelInferrer.this._typeReferenceBuilder.typeRef(rule.getSource().getMetaclass().getInstanceTypeName()));
              _builder.append(_typeRef_1);
              _builder.append(" input =");
              _builder.newLineIfNotEmpty();
              _builder.append("\t");
              JvmTypeReference _typeRef_2 = KampRuleLanguageJvmModelInferrer.this._typeReferenceBuilder.typeRef(Stream.class);
              _builder.append(_typeRef_2, "\t");
              _builder.append(".of(");
              String _firstLower = StringExtensions.toFirstLower(rule.getSource().getMetaclass().getName());
              _builder.append(_firstLower, "\t");
              _builder.append(");");
              _builder.newLineIfNotEmpty();
              _builder.newLine();
              {
                EList<Lookup> _lookups = rule.getLookups();
                for(final Lookup x : _lookups) {
                  CharSequence _generateCodeForRule = KampRuleLanguageJvmModelInferrer.this.generateCodeForRule(x, theClass);
                  _builder.append(_generateCodeForRule);
                  _builder.newLineIfNotEmpty();
                }
              }
              _builder.newLine();
              _builder.append("return ");
              String _get = KampRuleLanguageJvmModelInferrer.this.nameForLookup.get(IterableExtensions.<Lookup>last(rule.getLookups()));
              _builder.append(_get);
              _builder.append(".collect(");
              JvmTypeReference _typeRef_3 = KampRuleLanguageJvmModelInferrer.this._typeReferenceBuilder.typeRef(Collectors.class);
              _builder.append(_typeRef_3);
              _builder.append(".toSet());");
              _builder.newLineIfNotEmpty();
            }
          };
          this._jvmTypesBuilder.setBody(it, _client);
        };
        return this._jvmTypesBuilder.toMethod(rule, this.getLookupMethodName(rule), this._typeReferenceBuilder.typeRef(Set.class, this._typeReferenceBuilder.typeRef(this.getReturnType(rule).getInstanceTypeName())), _function_2);
      };
      List<JvmOperation> _map = ListExtensions.<KampRule, JvmOperation>map(element.getRules(), _function_1);
      this._jvmTypesBuilder.<JvmMember>operator_add(_members, _map);
    };
    acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, element.getName()), _function);
  }
  
  public EClass getReturnType(final KampRule rule) {
    return KampRuleLanguageEcoreUtil.getMetaclass(IterableExtensions.<Lookup>last(rule.getLookups()));
  }
  
  public String getLookupMethodName(final KampRule rule) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("lookup");
    String _firstUpper = StringExtensions.toFirstUpper(rule.getName());
    _builder.append(_firstUpper);
    _builder.append("From");
    String _firstUpper_1 = StringExtensions.toFirstUpper(rule.getSource().getMetaclass().getName());
    _builder.append(_firstUpper_1);
    return _builder.toString();
  }
  
  /**
   * <p>Generates the code that is embedded in the method if the given lookup
   * is found in a chain of lookups of one rule.
   * 
   * <p>The rule file can be navigated using the given lookup and methods in
   * {@link EcoreUtil}.
   * 
   * @param lookup the Lookup to generate the code for. There should be a
   * dispatch method for every sub type. Otherwise the generator will throw
   * a runtime exception.
   * 
   * @param typeToAddTo the class that is currently generated. Can be used to add further
   * methods or fields with the injected extension {@link JvmTypesBuilder}.
   */
  protected CharSequence _generateCodeForRule(final Lookup lookup, final JvmGenericType typeToAddTo) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// rule: ");
    String _string = null;
    if (lookup!=null) {
      _string=lookup.toString();
    }
    _builder.append(_string);
    _builder.append(", pre: ");
    Lookup _previousSiblingOfType = EcoreUtil.<Lookup>getPreviousSiblingOfType(lookup, Lookup.class);
    String _string_1 = null;
    if (_previousSiblingOfType!=null) {
      _string_1=_previousSiblingOfType.toString();
    }
    _builder.append(_string_1);
    return _builder;
  }
  
  /**
   * @see #generateCodeForRule(Lookup, JvmGenericType)
   */
  protected CharSequence _generateCodeForRule(final ForwardEReference ref, final JvmGenericType typeToAddTo) {
    CharSequence _xblockexpression = null;
    {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("marked");
      String _firstUpper = StringExtensions.toFirstUpper(KampRuleLanguageEcoreUtil.getMetaclass(ref).getName());
      _builder.append(_firstUpper);
      String varName = _builder.toString();
      this.nameForLookup.put(ref, varName);
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Stream<");
      String _instanceTypeName = KampRuleLanguageEcoreUtil.getMetaclass(ref).getInstanceTypeName();
      _builder_1.append(_instanceTypeName);
      _builder_1.append("> ");
      _builder_1.append(varName);
      _builder_1.append(" = ");
      String _get = this.nameForLookup.get(EcoreUtil.<Lookup>getPreviousSiblingOfType(ref, Lookup.class));
      _builder_1.append(_get);
      _builder_1.newLineIfNotEmpty();
      {
        boolean _isMany = ref.getFeature().isMany();
        if (_isMany) {
          _builder_1.append("\t");
          _builder_1.append(".flatMap(it -> ");
          _builder_1.newLine();
          _builder_1.append("\t");
          _builder_1.append("\t");
          _builder_1.append("it.get");
          String _firstUpper_1 = StringExtensions.toFirstUpper(ref.getFeature().getName());
          _builder_1.append(_firstUpper_1, "\t\t");
          _builder_1.append("().stream());");
          _builder_1.newLineIfNotEmpty();
        } else {
          _builder_1.append("\t");
          _builder_1.append(".map(it -> it.get");
          String _firstUpper_2 = StringExtensions.toFirstUpper(ref.getFeature().getName());
          _builder_1.append(_firstUpper_2, "\t");
          _builder_1.append("());");
          _builder_1.newLineIfNotEmpty();
        }
      }
      _xblockexpression = _builder_1;
    }
    return _xblockexpression;
  }
  
  /**
   * @see #generateCodeForRule(Lookup, JvmGenericType)
   */
  protected CharSequence _generateCodeForRule(final BackwardEReference ref, final JvmGenericType typeToAddTo) {
    CharSequence _xblockexpression = null;
    {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("backmarked");
      String _firstUpper = StringExtensions.toFirstUpper(ref.getMetaclass().getName());
      _builder.append(_firstUpper);
      String varName = _builder.toString();
      this.nameForLookup.put(ref, varName);
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Stream<");
      String _instanceTypeName = ref.getMetaclass().getInstanceTypeName();
      _builder_1.append(_instanceTypeName);
      _builder_1.append("> ");
      _builder_1.append(varName);
      _builder_1.append(" = null;");
      _builder_1.newLineIfNotEmpty();
      _builder_1.append("// iterate over all resources and filter stuff out");
      _builder_1.newLine();
      _xblockexpression = _builder_1;
    }
    return _xblockexpression;
  }
  
  public void infer(final EObject element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (element instanceof RuleFile) {
      _infer((RuleFile)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element != null) {
      _infer(element, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(element, acceptor, isPreIndexingPhase).toString());
    }
  }
  
  public CharSequence generateCodeForRule(final Lookup ref, final JvmGenericType typeToAddTo) {
    if (ref instanceof BackwardEReference) {
      return _generateCodeForRule((BackwardEReference)ref, typeToAddTo);
    } else if (ref instanceof ForwardEReference) {
      return _generateCodeForRule((ForwardEReference)ref, typeToAddTo);
    } else if (ref != null) {
      return _generateCodeForRule(ref, typeToAddTo);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(ref, typeToAddTo).toString());
    }
  }
}
